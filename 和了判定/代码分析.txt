1、“AgariIndex.java”程序的行为和“麻雀 和了判定（役の判定） アルゴリズム”中描述的并不完全一致。
不一致的情况为：该程序算出的key值的最后一位（最高位）永远是1，不管最后一枚牌是中张牌还是幺九牌（包括老头牌和字牌）。
这主要是由程序的逻辑决定的，可以参考程序的74、99、122行。
不过这并不会对和了判断造成什么影响，因为原描述中的Index方法，符号化前的序列最后一位必定不为0，所以符号化后序列的最后一位必定为0（所以原描述的Index方法实际上最多只需要26bit大小的数据用来符号化一个序列）。现在只是把所有的最后1位（最高位）由0改为了1而已。这样也就使用了最多27bit大小的数据用来符号化一个序列。

2、可以事先判断的役不仅有七对子、一盃口、两盃口、一气通贯、九莲宝灯，还有对对和、三暗刻、四暗刻。然而存储刻子数（3bit，0~4）+顺子数（3bit，0~4）+雀头位置（4bit，0~12）+四个面子位置（从刻子到顺子的顺序，4bit×4，0~11）+七对子标志（1bit，0/1）+九莲宝灯标志（1bit，0/1）+一气通贯标志（1bit，0/1）+两盃口标志（1bit，0/1）+一盃口标志（1bit，0/1）已经用了31bit（3×2+4×5+5=31bit），也就只有再添加一个役种标志的余裕了。如果超过32bit，就需要使用64bit的大小来存储单个数据，需要的空间就翻倍了。不过如果有64bit的空间的话也就可以存储更多的附加信息了。（雀头位置和面子位置指的是雀头的牌、刻子的牌、顺子的第1枚牌在排好序的手牌中是第几枚，手牌的排序顺序是从“一万”~“九万”、再从“①筒”~“⑨筒”、之后是“1索”~“9索”、最后是“东→南→西→北→白→发→中”。由于面子必定占3枚牌，且顺子的位置指的是顺子的第1枚牌的位置，所以面子位置的数值范围是0~11，又由于一般和了形必然有雀头，所以面子位置的数值范围是0~10。（更精确地说，没有刻子的情况下，面子位置的范围是0~10，有一个刻子的情况下，面子位置的数值范围也是0~10，有两个刻子的情况下，面子位置的数值范围是0~8，有三个刻子的情况下，面子位置的数值范围是0~6，有四个刻子的情况下，面子位置的数值范围是0~4。）同样地，雀头占2枚牌，所以雀头位置的数值范围是0~12。刻子数和顺子数其实可以只存储一个，因为一般和了形的话，刻子数+顺子数=4，这样的话就可以多存储3bit的数据了。）

3、“ptn.rb”程序中的find_hai_pos函数在处理七对子形时，会先把它看作一般形，如果符合一般形，那么程序在226行就会返回函数结果，就不会再判断它是否符合七对子形。也就是说，只有那些仅符合七对子形，不符合一般形的手牌会在返回值的第26个bit的位置将七对子标志置一。

4、“ptn.rb”程序中的Array.perms函数的作用是：列出给定的Array数组对象的全部元素的所有不重复的排列。该函数中使用了递归（回溯）的方法，在找到一个元素后，通过递归寻找排列的下一个元素。由于程序中7~11行的：
array.inject([]) do |rs, h|
	block
end
这段代码在运行block内的语句前会将inject的参数[]赋给rs，并且每次循环后将block的值（block中最后一条语句的值）更新到rs中，所以可以在同一个排列的位置更换不同的元素。
嵌套数组的相加问题：可以看到程序中第10行代码：“rs + tmp.perms.map {|t| [h] + t}”，
由于第6行递归结束条件：“return [[]] if empty?”，所以最后一层递归返回tmp.perms的值为[[]]，所以tmp.perms的元素t的值为[]，而h为一层嵌套（如[1,1,1]），则[h]为二层嵌套，所以[h]+t也为二层嵌套，是故tmp.perms.map方法的返回值为三层嵌套。除最后一层递归的返回值外，tmp.perms的值都为三层嵌套的数组，t的值都为二层嵌套的数组。rs的初始值为[]一层嵌套，rs+tmp.perms.map返回值=该返回值，结果为三层嵌套，该结果随后更新到rs的值中，于是此后rs都为三层嵌套。

5、“ptn.rb”程序中的ptn函数的作用是，通过循环找出给定的a数组里的任意2个元素（面子、对子）通过各种形式的重叠后成为1个部分后构成的新数组，并将这个新数组再作为a数组放入新的ptn函数内进行递归运算。于是，这相当于可以找出最初给定的a数组中任意2个、3个等多个元素（面子或对子）构成1个或多个部分后可能构成的所有新牌形。
同时，ptn函数开始时会调用array.perms函数计算出给定面子对子组合不考虑相邻和重叠情况时的所有排列。所以，通过ptn函数可以找出所有给定面子对子组合的包含相邻和重叠情况的所有排列。
当然，其中可能会有重复，所以ptn函数中使用了Hash变量来存储排列的形状数据到key值，需要添加新的排列时，先查找Hash变量中是否已经存储有相同的key值的排列，已经存在该key值的情况下就可以跳过这个排列了。（这里Hash变量只需要用到key值，不需要用到value，所以value就直接赋予nil的空值就行了。）
ptn函数内实际使用了两个Hash变量，一个是h1，用来存储当前函数里固定面子和对子的数量和类型时，所有不同位置两个面子或对子的不相邻排列的key值，用来排除不同位置的面子和对子却有相同形状的情况下的重复组合，另一个是h2，用来存储当前循环里固定位置的两个面子或对子相邻或重叠的不同排列的key值，用来排除固定位置时不同形式的相邻或重叠却有相同形状的情况下的重复组合。
即使这样，如果还会有重复的话，在程序的第246、253、259、264、268行的门清、一副露、两副露、三副露、四副露的五个ptn分组中的().uniq.each中也会被筛选掉的。
